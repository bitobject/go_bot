# --- Этап 1: Сборщик (Builder) ---
# Используем конкретную версию Go на базе Alpine для консистентности и малого размера.
FROM golang:1.21-alpine AS builder

# Устанавливаем рабочую директорию.
WORKDIR /src

# 1. КОПИРУЕМ ТОЛЬКО ФАЙЛЫ ЗАВИСИМОСТЕЙ
# Этот слой кэшируется и пересобирается только при изменении go.mod или go.sum.
COPY go.mod go.sum ./

# 2. СКАЧИВАЕМ ЗАВИСИМОСТИ
# Этот шаг занимает много времени, но теперь он будет кэшироваться.
RUN go mod download

# 3. КОПИРУЕМ ВЕСЬ ОСТАЛЬНОЙ ИСХОДНЫЙ КОД
# Этот слой будет пересобираться при каждом изменении вашего кода, но предыдущий останется в кэше.
COPY . .

# 4. СОБИРАЕМ ПРИЛОЖЕНИЕ С ОПТИМИЗАЦИЯМИ
#   - CGO_ENABLED=0: Создает статически скомпилированный бинарник без C-зависимостей.
#   - -ldflags="-w -s": Удаляет отладочную информацию, значительно уменьшая размер бинарника.
#   - Убран флаг "-a", который принудительно пересобирал всё, игнорируя кэш.
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-w -s" -o /bin/app ./cmd/bot


# --- Этап 2: Финальный образ ---
# Используем scratch для минимального размера
FROM scratch

# Копируем только скомпилированное приложение из этапа сборщика.
COPY --from=builder /bin/app /app

# Копируем CA-сертификаты для HTTPS-запросов
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt

# Устанавливаем переменные окружения для Go, чтобы он знал где искать CA сертификаты
ENV SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
ENV SSL_CERT_DIR=/etc/ssl/certs

# Создаем непривилегированного пользователя.
# Хотя в 'scratch' нет оболочки для создания пользователя, мы можем указать UID/GID.
# Если вы используете 'alpine', то сначала нужно создать пользователя:
# RUN addgroup -S appgroup && adduser -S appuser -G appgroup
# USER appuser

# Указываем, какой порт слушает приложение (только для информации, не открывает порт).
EXPOSE 8080

# Команда для запуска нашего скомпилированного приложения.
ENTRYPOINT ["/app"]